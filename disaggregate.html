
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Chapter 5: Advanced Capabilities Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-intopic-toc/style.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="impl.html" />
    
    
    <link rel="prev" href="ran.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    About
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="preface.html">
            
                <a href="preface.html">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="intro.html">
            
                <a href="intro.html">
            
                    
                    Chapter 1: Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="primer.html">
            
                <a href="primer.html">
            
                    
                    Chapter 2: Wireless Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="arch.html">
            
                <a href="arch.html">
            
                    
                    Chapter 3: Basic Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ran.html">
            
                <a href="ran.html">
            
                    
                    Chapter 4: RAN Internals
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7" data-path="disaggregate.html">
            
                <a href="disaggregate.html">
            
                    
                    Chapter 5: Advanced Capabilities
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="impl.html">
            
                <a href="impl.html">
            
                    
                    Chapter 6: Exemplar Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="cloud.html">
            
                <a href="cloud.html">
            
                    
                    Chapter 7: Cloudification of Access
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Chapter 5: Advanced Capabilities</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="chapter-5-advanced-capabilities">Chapter 5: Advanced Capabilities</h1>
<p>Disaggregating the cellular network pays dividends. This section
explores three examples. Stepping back to look at the big picture, the
Architecture section described &#x201C;what is&#x201D; (the basics of 3GPP) and the
RAN Internals section described &#x201C;what will be&#x201D; (where the industry,
led by the O-RAN Alliance, is clearly headed), whereas this section
describes &#x201C;what could be&#x201D; (our best judgement on cutting-edge
capabilities that will eventually be realized).</p>
<h2 id="optimized-data-plane">Optimized Data Plane</h2>
<p>There are many reasons to disaggregate functionality, but one of the
most compelling is that by decoupling control and data code paths, it
is possible to optimize the data path. This can be done, for example,
by programming it into specialized hardware. Modern white-box
switches with programmable packet forwarding pipelines are a perfect
example of specialized hardware we can exploit in the cellular
network. <a href="#e2e">Figure 5.1</a> shows the first step in the process of
doing this. The figure also pulls together all the elements we&#x2019;ve
been describing up to this point. There are several things to note
about this diagram.</p>
<figure>
    <a id="e2e"></a>
    <img src="figures/Slide21.png" width="600px">
    <figcaption>Figure 5.1: End-to-end disaggregated system, including
    Mobile Core and Split-RAN.</figcaption>
</figure>

<p>First, the figure combines both the Mobile Core and RAN elements,
organized according to the major subsystems: Mobile Core, Central Unit
(CU), Distributed Unit (DU), and Radio Unit (RU). The figure also
shows one possible mapping of these subsystems onto physical
locations, with the first two co-located in a Central Office and the
latter two co-located in a cell tower. As discussed earlier, other
configurations are also possible.</p>
<p>Second, the figure shows the Mobile Core&#x2019;s two user plane elements
(PGW, SGW) and the Central Unit&#x2019;s single user plane element (PDCP)
further disaggregated into control/user plane pairs, denoted PGW-C /
PGW-U, SGW-C / SGW-U, and PDCP-C / PDCP-U, respectively. Exactly how
this decoupling is realized is a design choice (i.e., not specified by
3GPP), but the idea is to reduce User Plane component to the minimal
Receive-Packet / Process-Packet / Send-Packet processing core, and
elevate all control-related aspects into the Control Plane component.</p>
<p>Third, the PHY (Physical) element of the RAN pipeline is split between
the DU and RU partition. Although beyond the scope of this book, the
3GPP spec specifies the PHY element  as a collection of functional
blocks, some of which can be effectively implemented by software
running on a general-purpose processor and some of which are best
implemented in specialized hardware (e.g., a Digital Signal
Processor). These two subsets of functional blocks map to the PHY
Upper (part of the DU) and the PHY Lower (part of the RU),
respectively.</p>
<p>Fourth, and somewhat confusingly, <a href="#e2e">Figure 5.1</a> shows the PCDP-C
element and the Control Plane (Forwarding) element combined into a
single functional block, with a data path (blue line) connecting that
block to both the RLC and the MME. Exactly how this pair is realized
is an implementation choice (e.g., they could map onto two or more
microservices), but the end result is that they are part of an
end-to-end path over which the MME can send control packets to the
UE. Note that this means responsibility for demultiplexing incoming
packets between the control plane and user plane falls to the RLC.</p>
<figure>
    <a id="e2e-p4"></a>
    <img src="figures/Slide22.png" width="600px">
    <figcaption>FIgure 5.2: Implementing data plane elements of the
    User Plane in programmable    switches.</figcaption>
</figure>

<p><a href="#e2e-p4">Figure 5.2</a> shows why we disaggregated these components: it
allows us to realize the three user plane elements (PGW-U, SGW-U,
PDCP-U) in switching hardware. As we will expand on in more detail in
a later section, this can be done using a combination of a language
that is tailored for programming forwarding pipelines (e.g., P4), and
a protocol-independent switching architecture (e.g., Tofino). For now,
the important takeaway is that the RAN and Mobile Core user plane can
be mapped directly onto an SDN-enabled data plane.</p>
<p>Pushing RAN and Mobile Core forwarding functionality into the
switching hardware results in overlapping terminology that can
sometimes be confusing. 5G separates the functional blocks into
control and user planes, while SDN disaggregates a given functional
block into control and data plane halves. The overlap comes from our
choosing to implement the 5G user plane by splitting it into its
SDN-based control and data plane parts. As one simplification, we
refer to the Control Plane (Forwarding) and PDCP-C combination as the
CU-C (Central Unit - Control) going forward.</p>
<p>Finally, the SDN-prescribed control/data plane disaggregation comes
with an implied implementation strategy, namely, the use of a scalable
and highly available <em>Network Operating System (NOS)</em>. Like a
traditional OS, a NOS sits between application programs (control apps)
and the underlying hardware devices (whitebox switches), providing
higher levels abstractions (e.g., network graph) to those applications,
while hiding the low-level details of the underlying hardware. To make
the discussion more concrete, we use ONOS (Open Network Operating
System) as an example NOS, where PGW-C, SGW-C, and PDCP-C are all
realized as control applications running on top of ONOS.</p>
<figure>
    <a id="onos"></a>
    <img src="figures/Slide23.png" width="400px">
    <figcaption>FIgure 5.3: Control Plane elements of the User Plane
    implemented as Control Applications running on an SDN Controller
    (e.g., ONOS).</figcaption>
</figure>

<p><a href="#onos">Figure 5.3</a> shows one possible configuration, in which the
underlying switches are interconnected to form a leaf-spine
fabric. Keep in mind that the linear sequence of switches implied by
<a href="#e2e-p4">Figure 5.2</a> is logical, but that in no way restricts the
actual hardware to the same topology. The reason we use a leaf-spine
topology is related to our ultimate goal of building an edge cloud,
and leaf-spine is the proto-typical structure for such cloud-based
clusters. This means the three control applications must work in
concert to implement an end-to-end path through the fabric, which in
practice happens with the aid of other, fabric aware, control
applications (as implied by the &#x201C;...&#x201D; in the Figure). We describe the
complete picture in more detail in a later section, but for now, the
big takeaway is that the control plane components of the 5G overlay
can be realized as control applications for an SDN-based underlay.</p>
<h2 id="multi-cloud">Multi-Cloud</h2>
<p>Another consequence of disaggregating functionality is that once
decoupled, different functions can be placed in different physical
locations. We have already seen this when we split the RAN, placing
some functions (e.g., the PCDP and RRC) in the Central Unit and others
(e.g., RLC and MAC) in Distributed Units. This allows for simpler
(less expensive) hardware in remote locations, where there are often
space, power, and cooling constraints.</p>
<p>This process can be repeated by distributing the more centralized
elements across multiple clouds, including large datacenters that
already benefit from elasticity and economies of scale.
<a href="#multicloud">Figure 5.4</a> shows the resulting multi-cloud realization
of the Mobile Core. We leave the user plane at the edge of the network
(e.g., in the Central Office) and move control plane to a centralized
cloud. It could even be a public cloud like Google or Amazon. This
includes not only the MME, PCRF and HSS, but also the PGW-C and SGW-C
we decoupled in the previous section. (Note that
<a href="#multicloud">Figure 5.4</a> renames the PDCP-U from earlier diagrams as
the CU-U; either label is valid.) </p>
<figure>
    <a id="multicloud"></a>
    <img src="figures/Slide24.png" width="600px">
    <figcaption>FIgure 5.4: Multi-Cloud implementation, with MME, HSS,
    PCRF and    Control Plane elements of the PGW and SGW running in a
    centralized cloud.</figcaption>
</figure>

<p>What is the value in doing this? Just like the DU and RU, the Edge
Cloud likely has limited resources. If we want room to run new edge
services there, it helps to move any components that need not be local
to a larger facility with more abundant resources. Centralization also
facilitates collecting and analyzing data across multiple edge
locations, which is harder to do if that information is distributed
over multiple sites. (Analytics performed on this data also benefits
from having abundant compute resources available.)</p>
<p>But there&#x2019;s another reason worth calling out: It lowers the barrier
for anyone (not just the companies that own and operate the RAN
infrastructure) to offer mobile services to customers. These entities
are called <em>MVNOs (Mobile Virtual Network Operators)</em> and one clean
way to engineer an MVNO is to run your own Mobile Core on a cloud of
your choosing.</p>
<h2 id="network-slicing">Network Slicing</h2>
<p>One of the most compelling value propositions of 5G is the ability to
differentiate the level of service offered to different applications
and customers. Differentiation, of course, is key to being able to
charge some customers more than others, but the monetization case
aside, it is also necessary if you are going to support such widely
varying applications as streaming video (which requires high bandwidth
but can tolerate larger latencies) and Internet-of-Things (which has
minimal bandwidth needs but requires extremely low and predictable
latencies).</p>
<p>The mechanism that supports this sort of differentiation is called
network slicing, and it fundamentally comes down to scheduling, both
in the RAN (deciding which segments to transmit) and in the Mobile
Core (scaling microservice instances and placing those instances on
the available servers). The following introduces the basic idea,
starting with the RAN.</p>
<p>But before getting into the details, we note that a network slice is a
generalization of the QoS Class Index (QCI) discussed earlier. 3GPP
specifies a standard set of  network slices, called <em>Standardized
Slice Type (SST)</em> values. For example, SST 1 corresponds to mobile
broadband, SST 2 corresponds to Ultra-Reliable Low Latency
Communications, SST 3 corresponds to Massive IoT, and so on. It is
also possible to extend this standard set with additional slice
behaviors, as well as define multiple slices for each SST (e.g., to
further differentiate subscribers based on priority).</p>
<h3 id="ran-slicing">RAN Slicing</h3>
<p>We start by reviewing the basic scheduling challenge previewed in
Section 2. As depicted in <a href="#slicing-sched">Figure 5.5</a>, the radio
spectrum can be conceptualized as a two-dimensional grid of <em>Resource
Blocks (RB)</em>, where the scheduler&#x2019;s job is to decide how to fill the
grid with the available segments from each user&#x2019;s transmission queue
based on CQI feedback from the UEs. To restate, the power of OFDMA is
the flexibility it provides in how this mapping is performed.</p>
<figure>
    <a id="slicing-sched"></a>
    <img src="figures/Slide27.png" width="450px">
    <figcaption>Figure 5.5: Scheduler allocating resource blocks to
    UEs.</figcaption>
</figure>

<p>While in principle one could define an uber scheduler that takes
dozens of different factors into account, the key to network slicing
is to add a layer of indirection, such that (as shown in
<a href="#hypervisor">Figure 5.6</a>), we perform a second mapping of Virtual RBs
to Physical RBs. This sort of virtualization is common in resource
allocators throughout computing systems because we want to separate
how many resources are allocated to each user from the decision as to
which physical resources are actually assigned. This
virtual-to-physical mapping is performed by a layer typically known as
a <em>Hypervisor</em>, and the important thing to keep in mind is that it is
totally agnostic about which user&#x2019;s segment is affected by each
translation.</p>
<figure>
    <a id="hypervisor"></a>
    <img src="figures/Slide28.png" width="600px">
    <figcaption>FIgure 5.6: Wireless Hypervisor mapping virtual
    resource blocks to physical resource blocks</figcaption>
</figure>

<p>Having decoupled the Virtual RBs from Physical RBs, it is now possible
to define multiple Virtual RB sets (of varying sizes), each with its
own scheduler. <a href="#multi-sched">Figure 5.7</a> gives an example with two
equal-sized RB sets, where the important consequence is that having
made the macro-decision that the Physical RBs are divided into two
equal partitions, the scheduler associated with each partition is free
to allocate Virtual RBs completely independent from each other. For
example, one scheduler might be designed to deal with high-bandwidth
video traffic and another scheduler might be optimized for low-latency
IoT traffic. Alternatively, a certain fraction of the available
capacity could be reserved for premium customers or other
high-priority traffic (e.g., public safety), with the rest shared
among everyone else.</p>
<figure>
    <a id="multi-sched"></a>
    <img src="figures/Slide29.png" width="600px">
    <figcaption>FIgure 5.7: Multiple schedulers running on top of
    wireless hypervisor.</figcaption>
</figure>

<p>Going one level deeper in the implementation details, the real-time
scheduler running in each DU receives high-level directives from the
near real-time scheduler running in the CU, and as depicted in
<a href="#slicing-control">Figure 5.8</a>, these directives make dual
transmission, handoff, and interference decisions on a per-slice
basis. A single RAN Slicing control application is responsible for the
macro-scheduling decision by allocating resources among a set of
slices. Understanding this implementation detail is important because
all of these control decisions are implemented by software modules,
and hence, easily changed or customized. They are not &#x201C;locked&#x201D; into
the underlying system, as they have historically been in 4G&#x2019;s eNodeBs.</p>
<figure>
    <a id="slicing-control"></a>
    <img src="figures/Slide30.png" width="350px">
    <figcaption>FIgure 5.8: Centralized near-realtime control
    applications cooperating    with distribute    real-time RAN
    schedulers.</figcaption>
</figure>

<h3 id="core-slicing">Core Slicing</h3>
<p>In addition to slicing the RAN, we also need to slice the Mobile
Core. In many ways, this is a well-understood problem, involving QoS
mechanisms in the network switches (i.e., making sure packets flow
through the switching fabric according to the bandwidth allocated to
each slice) and the cluster processors (i.e., making sure the
containers that implement each microservice are allocated sufficient
CPU cores to sustain the packet forwarding rate of the corresponding
slice).</p>
<p>But packet scheduling and CPU scheduling are low-level mechanisms.
What makes slicing work is to also virtualize and replicate the entire
service mesh that implements the Mobile Core. If you think of a slice
as a system abstraction, then that abstraction needs to keep track of
the set of interconnected set of microservices that implement each
slice, and then instruct the underlying packet schedulers to allocate
sufficient network bandwidth to the slice&apos;s flows and the underlying
CPU schedulers to allocate sufficient compute cycles to the slice&apos;s
containers.</p>
<p>For example, if there are two network slices (analogous to the two RAN
schedulers shown in <a href="#multi-sched">Figures 5.7</a> and
<a href="#slicing-control">5.8</a>), then there would also need to be two Mobile
Core service meshes: One set of AMF, SMF, UPF,... microservices
running on behalf of the first slice and a second set of AMF, SMF,
UPF,... microservices running on behalf of the second slice. These two
meshes would scale independently (i.e., include a different number of
container instances), depending on their respective workloads and QoS
guarantees. The two slices would also be free to make different
implementation choices, for example, with one optimized for massive
IoT applications and the other optimized for high-bandwidth AR/VR
applications.</p>
<p>The one remaining mechanism we need is a demultiplexing function that
maps a given packet flow (e.g., between UE and some Internet
application) onto the appropriate instance of the service mesh. This
is the job of the NSSF described in an earlier section: it is
responsible for selecting the mesh instance a given slice&#x2019;s traffic is
to traverse.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="ran.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 4: RAN Internals">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="impl.html" class="navigation navigation-next " aria-label="Next page: Chapter 6: Exemplar Implementation">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 5: Advanced Capabilities","level":"1.7","depth":1,"next":{"title":"Chapter 6: Exemplar Implementation","level":"1.8","depth":1,"path":"impl.md","ref":"impl.md","articles":[]},"previous":{"title":"Chapter 4: RAN Internals","level":"1.6","depth":1,"path":"ran.md","ref":"ran.md","articles":[]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","flexible-alerts","sequence-diagrams","creativecommons","intopic-toc","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"intopic-toc":{"label":"Content","selector":".markdown-section h2","visible":true},"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"flexible-alerts":{"danger":{"className":"danger","icon":"fa fa-ban","label":"Attention"},"note":{"className":"info","icon":"fa fa-info-circle","label":"Note"},"style":"callout","tip":{"className":"tip","icon":"fa fa-lightbulb-o","label":"Tip"},"warning":{"className":"warning","icon":"fa fa-exclamation-triangle","label":"Warning"}},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"disaggregate.md","mtime":"2019-09-11T16:45:49.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-12T21:26:46.177Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-anchorjs/anchor.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-intopic-toc/anchor.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-intopic-toc/gumshoe.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-intopic-toc/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

